import sys
sys.stdin = open("in.txt", "r")
"""
<풀이 과정>
* 총 풀이 시간 : 풀이시간 초과
1차 구상 3 : 23 ~ 3 : 56
1차 구현        ~ 4 : 22

코드트리 4회 제출 성공 ~ 4 : 38
실패 1 ) 에지 케이스 처음부터 사다리 놓인 게 없는 경우 고려 x
실패 2 ) 고칠 수 없는 경우 처리 x
실패 3 ) 시간 초과 -> 가지치기 안함
시도 4 ) 코드트리 통과

백준 시간 내 총 6회 제출 실패 ~ 4 : 55

2차 구상 : ~ 5시 20분
2차 구현 : 시간 내 실패
2차 구현 결과 : 코드 트리 정답, 백준 오답

3차 구상, 구현, 디버깅 2회 성공 ~ 22 : 41

*총평
결론적으로 오늘 문제를 맞추지 못한 이유는 구상이 아니라 문제 조건을 잘 봤지만 
구현 할 때 다른 걸 기입한 점을 알아차리지 못한 점이었습니다. 구상의 변화와 관련해 오늘은 자세히 남겨보고자 합니다.

먼저 오늘 구상은 크게 3번에 나누어 진행했습니다.
1차, 3차는 비슷한 방법이지만 시간 복잡도를 줄였고 2차는 아예 다른 방법을 사용했습니다.
1차와 3차는 사다리의 위치를 완전 탐색 후 정상적으로 작동하는지 판별하는 로직이었습니다. 둘의 차이는 3에서는 사다리 설치를 위해 탐색해야 할 영역
을 줄였다는 점입니다. 

반면 2차 구상은 전혀 다른 방법으로 이루어졌습니다. 홀수 개의 사다리가 설치된 칸수를 찾고 홀수개가 설치된 부분에는 한 개씩 사다리를 설치해주었습니다.
사실 1차 구상 2차 구상 모두 코드 트리를 통과했기 때문에 오히려 더 당혹스러웠습니다. 하지만 1차는 시간 초과 2차는 오답 판정을 받았습니다. 이리 저리 고민했지만
완전 탐색 후 사다리를 찾는 방법이 틀릴 수 없다고 생객하여 2차 구상을 포기하고 1차 구상의 시간 복잡도를 더 줄여보기로 했습니다.

3차 구상도 성공한 결과 1차에 비해 시간이 절반으로 줄어들었습니다. 하지마 여전히 백준에서는 시간초과가 발생했습니다. 이후 다른 문제를 풀고 다시 시도했습니다.
그 결과 문제에서 사다리 4개이 상은 설치하지 않는다는 조건을 depth > 3으로 주어야 하는데 depth > 4로 주었다는 점입니다. 이 부분은 특히 초반 코드 작성에서는
맞게 썼는데 디버깅 과정에서 바꿔 썼고 알아차리지 못했습니다.

문제의 조건을 다시 한 번 잘 읽어보라는 말이 오버래핑 됐습니다. 어제 드래곤 커브에서도 이러한 부분은 잘 발견되지 않아 주의해야할 것이라고 적었고 오늘 그 일이
실현됐습니다. 문제의 조건을 더 꼼꼼히 읽어야 하겠습니다.

구상 관련해서 마지막으로 기록할 점은 새롭운 구상을 작성하는 시간을 아직 제대로 확보하지 못한다는 점입니다. 오늘도 지난번보다는 길어졌지만 약속한 1시간 이전에
새로 풀기를 지키지 못했습니다. 이후 더 신경쓰도록 하겠습니다. 


<디버깅 포인트>
1. 문제 조건 명확히 읽지 않는 경우가 이제 문제다
1) 설치가 필요 없는 경우 체크 x 사다리 애초에 일자로만 구성된 경우
2) 사다리 설치가 3개 초과일 때는 -1을 출력해야 하는점
3) 4개부터는 설치 필요없는 점(이부분은 잘 해놓고 바꿨음)

2. 새롭게 시작하는 풀이 더 시간 확보하자!
"""

direction = [(0, 1), (1, 0), (1, 1)]
move_info = {0: [0, 2], 1: [1, 2], 2: [0, 1, 2]}


def dfs(r, c, d_idx):
    global answer

    if r == N - 1 and c == N - 1:
        answer += 1
        return

    if d_idx == 0:  # 가로 일 경우
        # 1. 다음 이동 ( 가로)
        dx, dy = direction[0]
        nr, nc = r + dx, c + dy
        if nr < N and nc < N and board[nr][nc] == 0:
            dfs(nr, nc, 0)
        # 2. 다음 이동 (대각선)
        dx, dy = direction[2]
        nr, nc = r + dx, c + dy
        if nr < N and nc < N and board[nr][nc] == 0 and board[nr - 1][nc] == 0 and board[nr][nc - 1] == 0:
            dfs(nr, nc, 2)

    if d_idx == 1:
        # 1. 다음 이동 (세로)
        dx, dy = direction[1]
        nr, nc = r + dx, c + dy
        if nr < N and nc < N and board[nr][nc] == 0:
            dfs(nr, nc, 1)
        # 2. 다음 이동 (대각선)
        dx, dy = direction[2]
        nr, nc = r + dx, c + dy
        if nr < N and nc < N and board[nr][nc] == 0 and board[nr - 1][nc] == 0 and board[nr][nc - 1] == 0:
            dfs(nr, nc, 2)

    if d_idx == 2:
        # 1. 다음 이동 ( 가로)
        dx, dy = direction[0]
        nr, nc = r + dx, c + dy
        if nr < N and nc < N and board[nr][nc] == 0:
            dfs(nr, nc, 0)
        # 1. 다음 이동 (세로)
        dx, dy = direction[1]
        nr, nc = r + dx, c + dy
        if nr < N and nc < N and board[nr][nc] == 0:
            dfs(nr, nc, 1)
        # 2. 다음 이동 (대각선)
        dx, dy = direction[2]
        nr, nc = r + dx, c + dy
        if nr < N and nc < N and board[nr][nc] == 0 and board[nr - 1][nc] == 0 and board[nr][nc - 1] == 0:
            dfs(nr, nc, 2)


N = int(input())

# 0 : 빈 칸 | 1 : 벽 -> (0, 0) (0, 1)은 항상 빈칸
board = []
for _ in range(N):
    board.append(list(map(int, input().split())))

answer = 0
dfs(0, 1, 0)
print(answer)