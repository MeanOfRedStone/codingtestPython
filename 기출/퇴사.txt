"""
<디버깅 포인트>
1. 풀이 컨셉을 애매하게 잡았습니다.
이전에 알고리즘을 공부한 교재에서 DP 예제 문제로 푼 문제였습니다. 15!을 완전탐색 할 수 없기 때문에 백트래킹으로 시간 복잡도를 개선하는 것과
이전에 사용한 DP 중 명확한 풀이 컨셉을 정하지 못했고 이도 저도 아닌 시도를 계속 반복하였습니다.

사실 재풀이 할 때의 방식을 풀이 시간 내에도 가지치기 방안 중 하나로 생각하고 있었습니다.
하지만 제대로 살펴보지 않고 잘 하지 못하는 풀이 방식을 계속 고민한 점은 주의해야할 것 같습니다.

2. 시간 복잡도 개선
1) 일하는 시간의 중복을 확인하는 방법을 바꾸었습니다.
처음 풀이는 일하는 시간을 모두 방문 배열에 표시하며 중복을 확인했습니다.
그 결과 5,000ms 의 시간을 사용했습니다.
다시 풀이할 때는 스케쥴에 저장한 할 수 있는 일의 시작과 끝을 계속해서 현재 일의 시작과 비교하며 개선했습니다.
방문 배열을 일일이 표시했다 지웠다 하는 것에 비해 2번만 비교를 하는 것은 상당한 효율을 가져다 주었습니다.


2) 결과 값 탐색의 횟수를 줄였습니다.
depth로만 종료 조건을 관리해야한다고 생각했던 점이 오판이었던 것 같습니다.
depth로 관리할 때는 N!의 일을 모두 찾아야만 했습니다. 따라서 사실 가장
근본적인 가지치기 대상인 탐색 횟수를 줄이지 못했습니다.

두 번째 풀이에서는 시간의 중복만 피하게 일을 모두 뽑고 명확한 종료지점의 설정보다 금액의 최댓값이 바뀔때마다 갱신했습니다.
그 결과 성공적으로 탐색 횟수를 줄여 시간을 개선할 수 있었습니다.

3) 결과
약 5000ms를 124ms의 시간으로 개선을 할 수 있었습니다.

<풀이 과정>
1 ~ 5차 제출 : 3시 52 ~ 5시 40분(약 2시간)

6차 제출 : 8시 20분 ~ 8시 42분

오늘은 처음으로 문제를 시간안에 제출하지 못한 날이었습니다.
이전에는 출력 조건을 제대로 확인하지 못해 제출하지 못했는데 오늘은
세 가지 요인으로 인해 풀이를 실패했다고 생각합니다.

첫 번째 요인으로는 이전에 풀었던 풀이 방식을 애매하게 기억했다는 점입니다.
이전에 풀이할때 DP 예제 중 하나로 현재 문제를 풀이했습니다. 평소 DP를
잘 하지 못한다고 생각함에도 예전에 풀었던 DP 방식에 계속 끌려 가지치기와
DP를 이도 저도 아니게 시도 했습니다.
시간 1~5차 실패까지 풀이 방식을 30분 단위로 애매하게 변화한 것은 큰 문제였습니다.

두 번째는 평소 약하다고 생각하는 가지치기 방식에 정신적으로 흔들렸던 것 같습니다.
사실 정답 제출의 풀이를 실패 과정에서도 떠올렸습니다.
마음이 흔들려 아는 방식은 시도하지 않고 못하는 DP를 구상하는 이도저도 아닌 풀이를 계속했습니다.

세 번째 유연한 대처를 하지 못했습니다. 백트래킹류의 문제는 항상 depth로만 종료조건을 관리해야
한다고 생각해 N!의 시간 복잡도를 개선하지 못했습니다. 이 문제에서는 사실상 시간의 중복을 피해가는
방식으로 관리하는 것이 관건이라고 생각합니다. 무조건 depth를 백트래킹에 사용하려고 하여 역효과
가 났다고 생각합니다.


<기록할만 한 점>
1. depth로만 백트래킹의 종료를 관리해야하는 것은 아니다

2. for loop를 통해 lst로 자료구조를 항상 관리하는 습관 -> 변수로 관리하는 방법 생각해보자
이전 야구 문제에서도 비슷하게 애먹었다.

3. 풀이 과정 생각나면 그 컨셉 시도라도 해보자
"""


def find_money(idx, money):
    global answer
    global work_visited
    global schedule

    if money > answer:
        answer = money

    for work_idx in range(1, N + 1):
        #1) 이전 날 고려 x
        if work_idx < idx:
            continue

        #1.5) 이미 한 일 지나감
        if work_visited[work_idx] == 1:
            continue

        #2)종료시간이 N보다 큰 경우 고려 x
        s, e, p = work[work_idx]
        if e > N:
            continue

        #3) scheudle과 겹치면 고려 x
        is_next = False
        if schedule:
            for st, et in schedule:
                if st <= s <= et:
                    is_next = True
        if is_next:
            continue

        #4) scheudle에 현재 일 삽입
        schedule.append((s, e))
        #5) 돈 갱신
        n_money = money + p
        #6)work 기록 표시
        work_visited[work_idx] = 1

        #7) 다음 방문
        find_money(work_idx, n_money)

        work_visited[work_idx] = 0
        schedule.pop()





N = int(input())

work = [[]]
for i in range(1, N + 1):
    t, p = map(int, input().split())

    s = i
    e = i + t - 1

    work.append((s, e, p))

work_visited = [0 for _ in range(N + 1)]
answer = 0
schedule = []
find_money(1, 0)
print(answer)